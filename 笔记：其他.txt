--C++标准库中的正则
#include <regex>
regex re("...")	//R"()"
smatch/cmatch  results;	
regex_match(str, [&results,] re)	--完全匹配
regex_search(str, [&results,] re)	--子串匹配即可
regex_replace()

smatch{	最后再赋值给str
//第一个sub是全部，其次就是()里匹配的
	begin()、end()、size()
	length(i=0) //第i个匹配字符串的长度
}

正则表达式笔记：Regular Expression
特殊字符： .^$()*+?{}[]\|
. 表示除了\n的任意单字符
^ 匹配行的开头
$ 匹配行的结尾
(xxx)嵌套正则表达式（子表达式） 		([[:w:]]+)	([[:d:]]+)		组，会保留下来的
(?:xxx)分组但不捕获
* 前面的元素可以重复任意多次(n>=0)
+ 前面的元素可以重复一次或多次(n>0)
? 前面的元素可以重复0次或1次(n=0,1)
- 尽可能短
*?尽量少地重复任意多次
+?尽量少地重复一次或多次
??尽可能地重复0/1次
{}指定元素重复的次数{n}{n,}{,n}{m,n}  m<=x<=n
[]定义范围，表示里面的一个字符, 例如：[abc] [0-9] [\w] [+] [^xxx]不匹配之一		
\ 转移字符, \"表示" , C++11中的 R"(...)"来减少转移字符的数量 R"(\d)" == \\d
| 或，匹配两侧字符串之一
str\b：空白字符左边的字符串		--\bstr：空白字符右边的字符串

replace：$num	表示子正则表达式()，$0是整个串，$1开始是子串

注：中文时，wstring+wregex

判断（写在正则前面）
(?:...)  匹配而不捕获该匹配的字符串
(?=...)  ...的内容出现才匹配  同(?<=...) 
(?!...)  ...的内容不出现才匹配

常用的：
\d(数字)
\w(字母/汉字/俄语/日语等/下划线/数字) 
\s(空白字符，空格/制表符/换行等)  
\b   和^&一样表位置，即\b的前后不能都是 \w   str1|str2
大小表示非
\D(非数字)    \W	  \S       \D

数字：
^-?\d*$ : 任意数字
^-?\d{n}$  : 任意n位的数字
^[1-9]\d*|0$ : 非负整数(前面加个-就是非正)
^(-?\d+)(\.\d+)$ : 浮点数
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ : 正浮点数(前面加-就是负)
字符：
^[\u4e00-\u9fa5]+$ : 汉字
^[A-Za-z0-9]+$ : 英文或字母 alnum
^[A-Za-z]+$ : 任意英文
^for : 以for开头
end$ : 以end结尾

--运算符优先级
成员：(), [], . , ->, ::
单目(←)：!, 位逻辑~, ++, --, -(负号), 指针*, 地址&, sizeof
算数：*, /, %, +, -
位移：<<, >>
条件：<, >, <=, >=, ==, !=
位逻辑：&, |, ^
逻辑：&&, ||
三目(←)：? :
赋值(←)：=, +=, -=, *=, /=, %=, ...
逗号：,

--UML
基类△—派生类
接口△--实现
包-->依赖
使用—>被使用   -use> 我这么写	
聚合◇->个体	不管理生命周期
组合◆->组件	管理生命周期

--目录
/根目录	./当前目录     ../父目录



