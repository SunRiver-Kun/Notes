--C++标准库中的正则
#include <regex>
regex re(R"(/d+)");	//wregex
cmatch result;	//cmath：char  smatch：string
//regex_search	子串匹配即可
//regex_replace	替换$1,$2...
bool ok = regex_match("123str456sxx789", [result,] re);	完全匹配
//sregex_iterator(str.cbegin(), str.cend(),re,flag=default),end;	for(;i!=end;++i) cout << i->str(0) << i->str(1) ...
//sregex_token_iterator(str.cbegin(), str.cend(),re,sub),end;	for(;i!=end;++i) cout << i->str()

正则表达式笔记：Regular Expression
特殊字符： .^$()*+?{}[]\|
. 表示除了\n的任意单字符
^ 匹配行的开头
$ 匹配行的结尾
()嵌套正则表达式（子表达式） 		([[:w:]]+)	([[:d:]]+)		组，会保留下来的
* 前面的元素可以重复任意多次(n>=0)
+ 前面的元素可以重复一次或多次(n>0)
? 前面的元素可以重复0次或1次(n=0,1)
*?尽量少地重复任意多次
+?尽量少地重复一次或多次
??尽可能地重复0/1次
{}指定元素重复的次数{n}{n,}{,n}{m,n}  m<=x<=n
[]定义范围，表示里面的一个字符,在里面可以不使用转移字符,例如：[abc] [0-9] [\w] [+]		[^xxx]不匹配之一
\ 转移字符, \"表示" , C++11中的 R"(...)"来减少转移字符的数量 R"(\d)" == \\d
| 或，匹配两侧字符串之一
str\b：空白字符左边的字符串		--\bstr：空白字符右边的字符串

replace：$num	表示子正则表达式()，$0是整个串，$1开始是子串

注：中文时，wstring+wregex

判断（写在正则前面）
(?:...)  匹配而不捕获该匹配的字符串
(?=...)  ...的内容出现才匹配  同(?<=...) 
(?!...)  ...的内容不出现才匹配

常用的：
\d(数字) \w(字母/汉字/俄语/日语等/下划线/数字) \s(空白字符，空格/制表符/换行等)  \b
\D(非数字)\W	  \S       \D

数字：
^-?\d*$ : 任意数字
^-?\d{n}$  : 任意n位的数字
^[1-9]\d*|0$ : 非负整数(前面加个-就是非正)
^(-?\d+)(\.\d+)$ : 浮点数
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ : 正浮点数(前面加-就是负)
字符：
^[\u4e00-\u9fa5]+$ : 汉字
^[A-Za-z0-9]+$ : 英文或字母 alnum
^[A-Za-z]+$ : 任意英文
^for : 以for开头
end$ : 以end结尾

--运算符优先级
成员：(), [], . , ->, ::
单目(←)：!, 位逻辑~, ++, --, -(负号), 指针*, 地址&, sizeof
算数：*, /, %, +, -
位移：<<, >>
条件：<, >, <=, >=, ==, !=
位逻辑：&, |, ^
逻辑：&&, ||
三目(←)：? :
赋值(←)：=, +=, -=, *=, /=, %=, ...
逗号：,

--位逻辑的妙用
flag一般是2的n次方
&：
	hasflag (flags&flag)!=0     
	2的次方  v!=0 && (v&(v-1))==0	x = x&(x-1)  去掉开头的1，最终一直是0
	统计位1的个数   count=0;  while(x) { ++count;  x = x&(x-1); }
| ：addflag flags = flags|flag
^ ：x^x = 0,  0^y =y , x^y^x = y

--UML
基类△—派生类
接口△--实现
包-->依赖
使用—>被使用   -use> 我这么写	
聚合◇->个体	不管理生命周期
组合◆->组件	管理生命周期