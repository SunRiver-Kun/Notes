
--事件转发
UnityEngine.Events.UnityEvent<>，编辑器可以添加public的参数或最多带一个参数的函数。添加时，最上面的dynamic表示代码传入对应参数
简单的也可以用System.Action<>，不过Action可能为空，而UnityEvent不为空
注：Action要判空，物体摧毁时要手动取消。
公开的UnityEvent会自己创建，在物体销毁后，只有函数无关物体才会调用！
子物体的析构函数在GameObject.Destroy时不会马上调用！ 艹

--核心
Application{	
	Quit()
}

Mathf{
	float Clamp(value, min, max)	--返回[min,max]之间的值
	float Lerp(a, b, time)		-- time[0~1]，按time插值
	float PingPong(t, max)	--摇摆t的值，且不大于max，也不小于0
	bool Approximately(a, b)	-- a==b，是否十分接近
	float DeltaAngle(a, b)		--计算两个角度间的夹角？	
	Ceil、Round(a)		--取整，System.Convert.ToInt32(a) , (int)
	Epsilon(很小的常量)、Infinity(正无穷)、NegativeInfinity(负无穷)、PI、Deg2Rad、Rad2Deg
}

Random{
	Range(a,b)	-- [a,b)
}

UnityEngine.SceneManagement{
	SceneManager{
		LoadScene(index,type)   --从0开始编号，bulid Settings最上面改
	}
}

Unity.Scene.SceneSystem{
	--SubScene
	LoadScene(SceneGUID)
	UnLoadScene(SceneGUID)
}

Entities{

}

--动画
Animation{	

}

--音/视频
AudioPlayer、AudioSource、VideoPlayer

--物理
Physics{		
	bool RayCast( pos, direction[,out hitobjs], distance[, layout] )	--check colliseder
	bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation);
	bool SphereCast(Vector3 origin, float radius, Vector3 direction, out RaycastHit hitInfo);
}	
XXCollider.Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance);
Camera.main.ScreenPointToRay(Input.mousePosition);

Rigidbody{
	SetDensity(float density)	--设置密度
	AddForce(Vector3 force, mode = ForceMode.Force)	--添加力
	AddTorque(Vector3 torque, mode = ForceMode.Force)	--添加力(转/扭)矩
	Sleep()	--强制让刚体睡眠至少一帧
	velocity(速度)、mass(质量,一般为0.1-10)、drag(摩擦力)
	
}

Transform{
	LookAt(Transform target, Vector3 worldUp)
	Vector3D TransformDirection( xxx.forward/right/up )
	position、eulerAngles、forward、right、up、rotation(四元素)}

Quaternion{
	Euler(0, angleDegrees, 0)	--按°来旋转，左手螺旋
}

XXX Constraint{
	Aim	//旋转
	Look At	//简化的旋转，对于摄像机，镜头始终指向forward，即它的Z轴
	Parent	//位移和旋转，有惯性？不灵活！
	Position、Rotation、Scale	//单个
--先加Look At，后加Postion，实现镜头跟踪物体。反之会出现剧烈抖动！    注：Move Up/Down等不改变组件的添加顺序！
--Active：激活约束，即Lock and Active
--Zero：重置偏移量等
--XXX Rest：静止时（权为0时）
--XXX Offset：运动时
--Freeze XXX：对与position是启用，对于Rotation是禁用
}

Joint 2D{	关节
距离	Distance：保持该刚体和另一个刚体或位置(None)的固定或最大距离
摩擦力	Friction：摩擦关节将对象之间的线速度和角速度降低到零
*铰链	Hinge：物体可绕某点旋转，电机
固定	Fixed：保持固定的距离和角度，弹簧，震动，锚点
*相关	Relative：保持固定的距离和角度，电机，偏移
*滑动	Slider：让物体只在一条直线上运动，电机，自动门/开关
弹簧	Spring：沿轴线施力，尝试让物体保持一定距离
目标	Target：尝试把物体移动到某点
*车轮	Wheel：弹簧让锚点沿Angle线重合，Motor让Connected Rigidbody转起来。挂车身上，车身把旋转关了避免翻车，车身用多边形碰撞器
}

Effector2D{  效应器，同一物体无法添加多个效应器
	Platform：控制碰撞图层、单向碰撞、消除侧向摩擦/弹性等
	Surface：传送带，通过可随机speed来控制的，和人物移动冲突
	Point：引力/斥力点，可加随机力，反线性或反平方比例力
	Buoyancy：漂浮，可加随机力
	Area：定向可加随机力
}



--输入/控制
Input{
	默认：下上全过程多次调用	Down：按下，一次	Up：弹起，一次
	bool GetButton(string)		bool GetKey(KeyCode)		bool GetMouseButton()
	bool GetButtonDown(string)		bool GetKeyDown(KeyCode)		bool GetMouseButtonDown()
	bool GetButtonUp(string)		bool GetKeyUp(KeyCode)		bool GetMouseButtonUp()
	float GetAxis("Horizontal" or "Vertical")  //float
	mousePosition
}

CharacterController{		不是很好用……
	CollisionFlags Move(Vector3 motion)	--不考虑重力，返回碰撞到的碰撞器
	SimpleMove(Vector3 speed)	--以 m/s 的速度移动(初速度)，自动添加重力
	isGrounded	--最后一次移动后，是否碰到地面
	velocity、slopeLimit、stepOffset(将影响刚体的下落速度！)
	、radius、height、center
}

--文件	
PlayerPrefs：通过key来保存数据，简单
ScriptObject：单独存数据，配合[CreateAssetMenu(menuName="Settings",fileName="Settings")]
System.IO{
	File
	TextReader/Writer
	BinaryReader/Writer
	Path
}
UnityEngine{
	JsonUtility
}

--时间
Time{
	  deltaTime	--帧之间的间隔
}

--绘制/GUI
GUI{	--坐标系采用屏幕坐标系（左上角）  	(0,0) ↓y →x	--写在 OnGUI，每帧至少执行2次（一绘制，二响应）
--有些时候要保存数据要建个类成员
--Screen.xxx	直接用
--可以在组件上加属性 [ExecuteInEditMode]，来“预览”，交互print不怎么样
	if( GUI.Button(...) )  { ... }  
	slidervalue = GUI.HorizontalSlider(new Rect(0, 0, 200, 1000), slidervalue, 0, 100);	//代码实时更新，不过print处理就有点问题
}
GUILayout、GUILayoutUtility
--调试/help
Debug{
	DrawRay( pos, vector, color)	--绘制射线
	Log(string)
}

Gizmos：{	--写在 OnDrawGizmos	OnDrawGizmoSelected
--绘制一些图案，帮忙确定距离等。在Game中不显示，而在Editor中实时显示
	Color
	DrawWireSphere、DrawIcon、DrawGUITextures	
}
